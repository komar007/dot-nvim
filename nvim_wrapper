#!/bin/sh

set -e

DIR=$(CDPATH='' cd -- "$(dirname -- "$0")" && pwd)

# Unload any previously loaded direnv, as neovim manages direnv itself
#
# The "hack" below is specific to the design of this neovim configuration where neovim is a nix
# package that contains its executable dependencies (LSPs, rg, etc.) as `runtimeInputs` which
# essentially makes it a wrapper that extends PATH before spawning original nvim. This causes
# problems if the nix package is started in a direnv-enabled environment, as the environment
# likely overrides PATH (especially with `use flake`).
#
# Not doing the unloading would cause direnv reloading inside NotAShelf/direnv.nvim to break
# runtimeInputs in direnv directories with `use flake` (or any PATH appending/prepending):
# - .envrc in current directory appends to PATH,
# - neovim wrapped in a subshell appending deps to PATH spawned (*),
# - :Direnv reload restores environment state serialized by direnv before entering current directory
#   causing changes to PATH introduced in (*) to be lost,
# - direnv applies new (or updated) .envrc,
# - result: neovim does not recognize dependencies: LSPs, basic tools, etc.
#
# Unloading the changes currently applied by direnv before spawning nvim wrapped with its
# dependencies (whether it's a package or devshell) makes sure that the dependencies provided by
# this flake are the starting point for any direnv reloads happening inside neovim and will not be
# lost. `autoload_direnv` makes sure that the current directory's .envrc will be immediately loaded
# anyway.
DIRENV_UNLOAD=""
if direnv --version > /dev/null; then
	T=$(mktemp -d) # guaranteed to have no .envrc
	cd "$T" > /dev/null || exit
	DIRENV_UNLOAD="$(direnv export bash)"
	cd - > /dev/null || exit
	rmdir "$T"
fi
eval "$DIRENV_UNLOAD"

NVIM_BIN="nvim" \
NVIM_BIN_ALT="$DIR/nix_run_nvim_with_here_config.sh" \
	"$DIR"/nvim_cold_reload/nvim_cold_reload.sh "$@"
